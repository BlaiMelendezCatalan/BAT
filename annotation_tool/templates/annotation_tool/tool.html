{% extends base_template %}
{% load staticfiles %}

{% block title %}Annotation tool{% endblock %}

{% block header %}Annotation tool{% endblock %}

{% block body_class %}loaded{% endblock %}

{% block body_block %}

  <script src="{% static 'js/annotator/lib/wavesurfer.min.js' %}"></script>
  <script src="{% static 'js/annotator/src/wavesurfer.regions.js' %}"></script>
  <script src="{% static 'js/annotator/colormap/colormap.min.js' %}"></script>
  <script src="{% static 'js/annotator/lib/wavesurfer.spectrogram.min.js' %}"></script>
  <script src="{% static 'js/annotator/src/wavesurfer.drawer.extended.js' %}"></script>
  <script src="{% static 'js/bootstrap-tokenfield.min.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/annotator/src/components.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/annotator/src/wavesurfer.labels.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/url.js' %}"></script>
  <link rel="stylesheet" href="{% static 'css/annotator/font-awesome.min.css' %}">
  <link rel="stylesheet" href="{% static 'css/bootstrap-tokenfield.min.css' %}">
  <div id="loader-text"><h1>Please wait...</h1></div>
  <div id="loader-wrapper">
    <div id="loader"></div>

    <div class="loader-section section-left"></div>
    <div class="loader-section section-right"></div>

  </div>

  <div class="container">
    <button type="button" class="btn btn-default" data-toggle="collapse" data-target="#tips-container">Annotation tips</button>
    <div class="collapse in" id="tips-container">
      <h5>Read and get used to the commands below. Annotation will be much easier.</h5>
      <h5>Do not worry about silences, we will annotate them for you.</h5>
    </div>
    <div>
    <button type="button" class="btn btn-default" data-toggle="collapse" data-target="#controls-container">Controls</button>
    </div>
    <div class="collapse" id="controls-container">
      <h5 class="common-control"><strong>Space bar</strong>: play / pause audio.
      </h5>
      {% if not regions %}
      <h5>
          <strong>Create new region</strong>: <strong>click</strong> and <strong>drag</strong> on the waveform.
      </h5>
      {% endif %}
      <h5 class="common-control">
        <strong>Select region</strong>: <strong>double-click</strong> on <strong>region</strong> or <strong>click</strong> on <strong>region's label</strong>.</h5>
      {% if not regions %}
        <h5><strong>Delete region</strong>: <strong>ctrl+Click</strong> on it or <strong>click</strong> on <strong>region's X button</strong>.</h5>
        <h5><strong>Set class</strong>: <strong>click</strong> on <strong>label</strong> or use the <strong>shortcut</strong>.</h5>
        <h5 class="only-without-overlap"><strong>Regions cannot overlap</strong>. Use this to <strong>easily concatenate regions.</strong></h5>
        <h5 class="only-without-overlap"><strong>'f' key</strong>: <strong>glue</strong> the selected region limits to the closer borders. <strong>f + Ctrl (+ Shift)</strong> glue them only to the <strong>left (right) limit</strong>.</h5>
      {% endif %}
      <h5 class="common-control"><strong>'s' key</strong>: set the <strong>player</strong> at the <strong>beginning</strong> of the audio.
      </h5>
      <h5 class="common-control"><strong>'b' key</strong>: set the <strong>player</strong> at the <strong>beginning</strong> of the <strong>selected region</strong>.</h5>
      {% if not regions %}
      <h5><strong>Adjusting limits</strong>: <strong>ctrl (+ Shift) + Left/Right Arrows</strong> precisely adjusts <strong>left (right) region limits</strong>.</h5>
      {% endif %}
    </div>
    &nbsp;
    <button id="switch-view" class="btn btn-success">Switch view</button>
    <div id="waveform"></div>

    <div style="text-align: center">
      <button class="btn btn-primary" id="play-pause-main-button">
        <i class="glyphicon glyphicon-play"></i>
        Play /
        <i class="glyphicon glyphicon-pause"></i>
        Pause
      </button>
    </div>

    {% if not request.is_superuser %}
      <div class="row control-form">
        <div class="col-md-12">
          <div style="float: right;">
            {% if project.overlap %}
              <button id="solve-overlaps-button" class="btn btn-warning">Solve overlaps</button>
              <button id="back-annotations-button" class="btn btn-warning">Back annotations</button>
            {% endif %}
            <button data-load-next="0" class="btn btn-primary finish-annotation-button">Finish annotation</button>
            <button data-load-next="1" class="btn btn-primary finish-annotation-button">Finish annotation and load next</button>
          </div>
        </div>
      </div>
    {% endif %}

    <div id="class-prominence-container">
      <div class="class-prominence-item fake-item">
        <div class="prominence-label-container">
          <div class="prominence-label"></div>
        </div>
        <div class="prominence-circles">
          {% for id, name in prominence_choices %}
            <div class="circle" data-toggle="tooltip" data-placement="bottom" data-id="{{ id }}"
                 title="{{ name }}"></div>
          {% endfor %}
        </div>
      </div>
    </div>

    <div class="row control-form">
      <div class="col-md-1" id="class-panel-header">Class</div>
      <div class="col-md-11">
        {% for name, color, shortcut in classes %}
          <div class="class-btn" data-class-color="{{ color }}" data-class-name="{{ name }}">{{ name }} <span class="shortcut">({{ shortcut }})</span></div>
        {% endfor %}
      </div>
    </div>
    <div class="row control-form tags-input-container">
      <div class="col-md-1" id="tags-panel-header">Tags</div>
      <div class="col-md-6">
        {% if not request.user.is_superuser %}
          <div class="col-md-8">
            <input type="text" class="form-control" id="tags-input" value="">
          </div>
          <div class="col-md-3"><button class="btn" id="tag_button">Add tags</button></div>
        {% endif %}
      </div>
    </div>
    <div class="row control-form">
      <div class="col-md-1" id="regions-mode-tag-container"><span id="regions-mode-tag-label">Tags</span></div>
      <div class="col-md-2"></div>
      <div class="col-md-7" id="tags-container"></div>
    </div>

    <div id="modal-window" class="modal fade" role="dialog">
      <div class="modal-dialog">

        <!-- Modal content-->
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal">&times;</button>
            <h4 class="modal-title"></h4>
          </div>
          <div class="modal-body">

          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div>

      </div>
    </div>
  </div>
  {% if request.user.is_superuser %}
    <style>
      .wavesurfer-region .fa-times-circle {
        display: none;
      }
    </style>
  {% endif %}
  {% if regions %}
    <style>
      .delete-tag-button {
        display: none;
      }
    </style>
  {% endif %}
  <script type="text/javascript">

    wavesurferHandler = {
      // contain all wavesurfers
      container: [],
      labels: [],

      getMainWavesurfer: function() {
        return this.container[0];
      },

      getAllRegions: function() {
        var regions = [];
        this.container.forEach(function (wavesurfer) {
          Object.keys(wavesurfer.regions.list).forEach(function (id) {
            regions.push(wavesurfer.regions.list[id]);
          });
        });
        return regions;
      },

      // Create color map for spectrogram
      getSpectrogramColorMap: function() {
        return colormap({
          colormap: magma,
          nshades: 256,
          format: 'rgb',
          alpha: 1
        });
      },

      addContainerForWavesurfer: function () {
        var mainContainer = $('#waveform'),
            lastContainer = mainContainer.find('.container:last'),
            lastId = lastContainer.length ? parseInt(lastContainer.data('container-id')) : 0,
            classForNewContainer = 'container-' + (lastId + 1);

        // labels
        var labelsContainer = $('<div></div>')
            .addClass('labels');

        // container
        var newContainer = $('<div></div>')
          .append(labelsContainer)
          .attr('data-container-id', lastId + 1)
          .addClass('container ' + classForNewContainer);

        mainContainer.append(newContainer);

        return '.' + classForNewContainer;
      },

      addWavesurfer: function () {
        var container = this.addContainerForWavesurfer(),
            colorMap = this.getSpectrogramColorMap(),
            wavesurfer = WaveSurfer.create({
              container: container,
              waveColor: 'violet',
              progressColor: 'purple',
              normalize: true,
              fillParent: true,
              height: WAVESURFER_HEIGHT,
              colorMap: colorMap,
              fftSamples: WAVESURFER_HEIGHT * 2
        });

        wavesurfer.setVolume(0);

        wavesurfer.params.visualization = '{{ visualization }}';

        wavesurfer.load("{% url 'media' tmp_segment_path %}");

        // Create labels (labels that appear above each region)
        var labels = Object.create(WaveSurfer.Labels);
        labels.init({
          wavesurfer: wavesurfer,
          container: container + ' .labels'
        });
        this.labels.push(labels);

        // Create the play button and time that appear below the wavesurfer
        var playBar = new PlayBar(wavesurfer);
        playBar.create();

        this.container.push(wavesurfer);

        this.bindEvents(wavesurfer);

        return wavesurfer;
      },

      isMainWavesurfer: function (wavesurfer) {
        return this.container.length && this.container[0] == wavesurfer;
      },

      seekTo: function (position) {
        this.container.forEach(function (wavesurfer) {
          wavesurfer.seekTo(position);
        });
      },

      disableDragSelection: function () {
        this.container.forEach(function (wavesurfer) {
          wavesurfer.disableDragSelection({});
        });
      },

      findRegionById: function (id) {
        for (var i in this.container) {
          var wavesurfer = this.container[i];
            if (wavesurfer.regions.list[id] != undefined) {
            return wavesurfer.regions.list[id];
          }
        }
        return null;
      },

      getWavesurferByRegion: function (region) {
        if (region != null) {
          for (var i in this.container) {
            var wavesurfer = this.container[i];
            if (wavesurfer.regions.list[region.id] == region) {
              return wavesurfer;
            }
          }
        }
        return null;
      },

      bindEvents: function (wavesurfer) {
        var isMainWavesurfer = this.isMainWavesurfer(wavesurfer),
            that = this;

        wavesurfer.on('region-created', function (region) {
          onRegionCreated(region);
        });

        wavesurfer.on('region-update-end', function (region, event, eventType) {
          if (eventType == 'drag') {
            return;
          }
          setTimeout(function () {
            var check_region = wavesurfer.regions.list[region.id];
            // region was deleted
            if (typeof check_region != 'undefined') {
              onRegionUpdateEnd(wavesurfer, region);
            }
          }, 50);
        });


        wavesurfer.on('region-removed', function (region) {
          setCurrentRegion(-1);
          redrawClassForRegion();
          var region_data = {event_id: region.attributes['event_id']};

          if (!('delete_event' in region.attributes)) {
            $.ajax({
              type: "POST",
              url: '{% url 'remove_event' %}',
              dataType: 'json',
              data: {
                region_data: JSON.stringify(region_data),
                csrfmiddlewaretoken: '{{csrf_token}}'
              },
              success: function (response) {
                that.checkOverlaps();
              }
            });
          } else {
            delete region.attributes['delete_event'];
          }
        });

        wavesurfer.on('region-dblclick', function (region, event) {
          setCurrentRegion(region.id);
          if (event.button == 0 && event.ctrlKey == false) {
            // open prominence window if Region have multi class
            var classes = typeof region.attributes.class != 'undefined' ? region.attributes.class.split(' ') : [];
            if (REGIONS_STATE && classes.length > 1) {
              toggleProminencePopup(classes, region, $(region.element).offset());
            }
          }
        });

        wavesurfer.on('region-click', function (region, event) {
          if (event.button == 0 && event.ctrlKey == true && !REGIONS_STATE) {
            region.remove();
            setCurrentRegion(-1);
          }
        });

        wavesurfer.on('ready', function () {
          {% if request.user.is_superuser %}
            wavesurfer.initRegions()
            wavesurfer.disableDragSelection({})
          {% else %}
            wavesurfer.enableDragSelection({})
          {% endif %}

          if (isMainWavesurfer) {
            loadRegions(wavesurfer);
            wavesurfer.play();
            that.labels[0].rearrange();
          }
        });
      },

      updateAllRegions: function () {
        this.getAllRegions().forEach(updateEvent);
      },

      playPause: function () {
        this.container.forEach(function (wavesurfer) {
          wavesurfer.playPause();
        });
      },

      addRegion: function(wavesurfer, classes, tags, id, start_time, end_time, color, loaded) {
        var attrs = {
          'class': classes,
          'tags': tags,
          'region_id': id,
          'event_id': id
        };

        if (loaded) {
          attrs['loaded'] = true;
        } else {
          attrs['created_overlap'] = true;
        }
        var region = wavesurfer.addRegion({
          attributes: attrs,
          start: start_time,
          end: end_time,
          color: color,
          drag: false,
          annotation: classes,
          {% if request.user.is_superuser %}
            resize: false
          {% endif %}
        });

        return region;
      },

      checkOverlaps: function () {
        var overlapWasFound = false,
            that = this;
        this.container.forEach(function (wavesurfer) {
          for (var i in wavesurfer.regions.list) {
            if (overlapWasFound) {
              break;
            }
            var current_region = wavesurfer.regions.list[i];
            that.container.forEach(function (temp_wavesurfer) {
              Object.keys(temp_wavesurfer.regions.list).forEach(function (id) {
                var temp_region = temp_wavesurfer.regions.list[id],
                    overlapType1 = temp_region.start < current_region.start && temp_region.end > current_region.end,
                    overlapType2 = current_region.start < temp_region.start && current_region.end > temp_region.end,
                    overlapType3 = current_region.start < temp_region.start && current_region.end > temp_region.start,
                    overlapType4 = current_region.start > temp_region.start && current_region.start < temp_region.end;
                if (overlapType1 || overlapType2 || overlapType3 || overlapType4) {
                  overlapWasFound = true;
                  return;
                }
              });
            });
          }
        });

      $('#solve-overlaps-button').attr('disabled', !overlapWasFound);
      return overlapWasFound;
    },

      init: function () {
        this.addWavesurfer().setVolume(1);
      }
    };

    wavesurferHandler.create = function (params) {
      var handler = Object.create(wavesurferHandler);
      handler.init(params);
      return handler;
    };


    // init
    var ALLOW_OVERLAPS = {% if project.overlap %}true{% else %}false{% endif %};
    var CLASS_DICT = {{ class_dict|safe }};
    var currentRegionId = -1;
    var OVERLAP_REGION_COLOR = 'rgba(220, 220, 220, 0.8)';
    var WAVESURFER_HEIGHT = 128;
    var REGIONS_STATE = false;
    var handler = new wavesurferHandler.create();

    $('#add-wavesurfer-button').on('click', function () {
      handler.addWavesurfer();
    });

    $('#play-pause-main-button').on('click', function () {
      handler.playPause();
    });

    function renderNumbersForControlPanel() {
      if (ALLOW_OVERLAPS) {
        $('.only-without-overlap').remove();
      }
      var index = 0,
          numbers = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮'];
      $('#controls-container h5').each(function () {
        $(this).prepend('<span class="number">' + numbers[index++] + '</span>&nbsp;');
      });
    }
    renderNumbersForControlPanel();

    function renderNumbersForTipsPanel() {
      var index = 0,
          numbers = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮'];
      $('#tips-container h5').each(function () {
        $(this).prepend('<span class="number">' + numbers[index++] + '</span>&nbsp;');
      });
    }
    renderNumbersForTipsPanel();

    function switchToRegionMode() {
      REGIONS_STATE = true;
      $('#solve-overlaps-button, region .fa-times-circle, #tag_button, region handle, #add-wavesurfer-button, #tags-input-tokenfield, .tags-input-container').hide();
      $('.class-btn').css('cursor', 'default');
      $('#back-annotations-button, #regions-mode-tag-label').show();
      handler.disableDragSelection();
    }

    function getUniqueItems(items) {
      var unique = [];
      items.forEach(function (item) {
        if (unique.indexOf(item) < 0) {
          unique.push(item);
        }
      });
      return unique;
    }

    function redrawClassForRegion(region) {
      $('.class-btn').removeClass('active');
      if (typeof region != 'undefined' && region != null && 'class' in region.attributes) {
        region.attributes['class'].split(' ').forEach(function (name) {
          if (name) {
            $('div[data-class-name=' + name + ']').addClass('active');
          }
        });
      }
    }

    $('.class-btn').on('click', function () {
      var region = handler.findRegionById(currentRegionId),
          data = $(this).data();
      if (region == null || REGIONS_STATE) {
        return null;
      }
      setClassForRegion(region, data.className, data.classColor);

    });

    function loadRegions(wavesurfer) {
      // Do it with AJAX and return all info for all regions
      {% if regions %}
        {% for region in regions %}
          var tags = [];
          {% for tag in region.tags.all %}
            tags.push('{{ tag.name }}')
          {% endfor %}
          var region = handler.addRegion(wavesurfer, '{{ region.classes.all|join:" " }}', tags, {{ region.id }}, {{ region.start_time }}, {{ region.end_time }}, '{{ region.color }}', true);
          {% if region.classes.count > 1 %}
            region.attributes.classProminences = {};
            {% for class_prominence in region.classes.all %}
              region.attributes.classProminences['{{ class_prominence.class_obj.name }}'] = {{ class_prominence.prominence|default_if_none:'0' }};
            {% endfor %}
          {% endif %}
        {% endfor %}
        switchToRegionMode();
      {% else %}
        {% for event in events %}
          var tags = [];
          {% for tag in event.tags.all %}
            tags.push('{{ tag.name }}')
          {% endfor %}
          handler.addRegion(wavesurfer, '{{ event.event_class|default_if_none:'' }}', tags, {{ event.id }}, {{ event.start_time }}, {{ event.end_time }}, '{{ event.color }}', true);
        {% endfor %}
      {% endif %}
      setCurrentRegion(-1);
    }

    function getDuration() {
      return handler.getMainWavesurfer().getDuration() - 0.0001;
    }

    function preventOverlappingsOnCreation(region) {
      var new_start = region.start,
          new_end = region.end,
          wavesurfer = handler.getMainWavesurfer();
      if (new_end > getDuration()) {
        new_end = getDuration()
      }
      number_of_partial_overlaps = 0;
      for (var id in wavesurfer.regions.list) {
        console.log(id)
        if (id == region.id) {
          continue;
        }
        var temp_region = wavesurfer.regions.list[id],
            offset = $(temp_region.element)[0].offsetLeft;

        if (region.start <= temp_region.end && region.end >= temp_region.start) {
          if (region.start >= temp_region.start && region.end <= temp_region.end) {
            new_start = -1;
            break;
          } else if (region.start <= temp_region.start && region.end >= temp_region.end) {
            new_start = -1;
            break;
          } else if (region.start <= temp_region.start && region.end <= temp_region.end) {
            number_of_partial_overlaps += 1;
            new_end = temp_region.start;
          } else if (region.start >= temp_region.start && region.end >= temp_region.end) {
            number_of_partial_overlaps += 1;
            new_start = temp_region.end;
          }
        }
      };
      if (number_of_partial_overlaps >= 2) {
        new_start = -1;
      }

      return [new_start, new_end]
    }


    function updateClassProminence(region_id, className, prominence) {
      $.ajax({
        type: "POST",
        url: '{% url 'class_prominence' %}',
        dataType: 'json',
        beforeSend: function (xhr) {
          xhr.setRequestHeader("X-CSRFToken", '{{ csrf_token }}');
        },
        data: {
          'region_id': region_id,
          'class_name': className,
          'prominence': prominence
        },
        success: function () {
          location.reload();
        }
      });
    }

    function toggleProminencePopup(classes, region, offset) {
      var popup = $('#class-prominence-container'),
          offsetLeft = offset.left;

      // close popup if click on same region
      if (popup.hasClass('active') && popup.offset().left == offsetLeft) {
        popup.removeClass('active');
        return;
      }

      // open popup
      popup.css({
        'top': (offset.top + WAVESURFER_HEIGHT) + 'px',
        'left': offset.left + 'px'
      });
      popup.addClass('active');

      // remove old classes
      popup.find('.class-prominence-item').not('.fake-item').remove();

      // add current classes
      var fakeItem = popup.find('.fake-item');
      for (var i in classes) {
        var newItem = fakeItem.clone(),
            className = classes[i];
        newItem.removeClass('fake-item');
        newItem.find('.prominence-label').text(className);
        var initProminence = region.attributes.classProminences[className];
        newItem.find('.circle[data-id=' + initProminence + ']').addClass('active');
        popup.append(newItem);

        // click on circle for set prominence
        $(newItem).find('.circle').on('click', function () {
          var className = $(this).closest('.class-prominence-item').find('.prominence-label').text(),
              prominence = $(this).data('id');
          updateClassProminence(region.attributes.region_id, className, prominence);
          region.attributes.classProminences[className] = prominence;

          // mark circle as active
          $(this).closest('.prominence-circles').find('.circle').removeClass('active');
          $(this).addClass('active');
        });
      }

      // activate tooltips
      $('[data-toggle="tooltip"]').tooltip();
    }

    function updateEvent(region) {
      var region_data = {
        event_id: region.attributes['event_id'],
        color: region.color,
        start_time: region.start,
        end_time: region.end,
        event_class: region.attributes['class'],
        tags: region.attributes['tags']
      };

      $.ajax({
        type: "POST",
        url: '../update_event/',
        dataType: 'json',
        data: {
          region_data: JSON.stringify(region_data),
          csrfmiddlewaretoken: '{{csrf_token}}'
        },
        success: function (response) {
        }
      });
    }

    function resetHTML() {
      redrawTagsForRegion();
      redrawClassForRegion();
    }

    function deleteTagFromRegion(region, tagName) {
      if (typeof region.attributes.tags != 'undefined') {
        var position = region.attributes.tags.indexOf(tagName);
        if (position != -1) {
          region.attributes.tags.splice(position, 1);
          updateEvent(region);
          redrawTagsForRegion(region);
        }
      }
    }


    function redrawTagsForRegion(region) {
      var container = $('#tags-container');
      container.empty();
      $('#tags-input').val('');

      if (typeof region != 'undefined' && region != null && 'tags' in region.attributes && typeof region.attributes.tags != 'undefined') {
        region.attributes['tags'].forEach(function (name) {
          if (!name.length) {
            return;
          }
          var deleteTagButton = $('<i></i>')
                  .addClass('fa fa-times-circle delete-tag-button')
                  .attr('data-tag-name', name);

          var tag = $('<div></div>')
                  .addClass('tag-element')
                  .text(name);

          deleteTagButton.on('click', function () {
            deleteTagFromRegion(region, $(this).data('tag-name'))
          });

          tag.append(deleteTagButton);
          container.append(tag);
        });
      }
    }

    function createNewRegion(fromRegion) {
      if (typeof fromRegion.deleted != 'undefined') {
        return;
      }
      var region_data = {
        color: fromRegion.color,
        start_time: fromRegion.start,
        end_time: fromRegion.end,
        tags: fromRegion.attributes.tags,
        classes: fromRegion.attributes.class,
        annotation: '{{ annotation.id }}'
      };
      $.ajax({
        type: "POST",
        url: '../create_region/',
        dataType: 'json',
        data: {
          region_data: JSON.stringify(region_data),
          csrfmiddlewaretoken: '{{csrf_token}}'
        },
        success: function (data) {
          console.log(data)
          fromRegion.attributes.region_id = data.region_id
        }
      });
    }

    function setCurrentRegion(id) {
      currentRegionId = id;
      $('tag').removeClass('active');
      if (currentRegionId != -1) {
        $('.region-label-' + currentRegionId).addClass('active');
        var region = handler.findRegionById(currentRegionId);
        if (region) {
          redrawTagsForRegion(region);
          redrawClassForRegion(region);
          updateRegionIndexes(region);
        }
      }
    }

    function updateRegionIndexes(region) {
      var baseZIndex = 1100;
      $('.wavesurfer-region').each(function () {
        $(this).css('z-index', baseZIndex++);
      });
      $('region[data-id=' + region.id + ']').css('z-index', 3000);
    }

    function disableDrag(region) {
      region.drag = false
    }


    {% if not request.user.is_superuser %}
      // WaveSurfer callbacks
      function onRegionCreated(region) {
        setCurrentRegion(region.id)
        disableDrag(region)

        resetHTML()

        if (!('loaded' in region.attributes) && !('created' in region.attributes) && !('created_overlap' in region.attributes)) {
          region.attributes['class'] = "None"
          region.attributes['tags'] = []
        } else if ('loaded' in region.attributes) {
          delete region.attributes['loaded']
        }
      }

      function onRegionUpdateEnd(wavesurfer, region) {
        if (REGIONS_STATE) {
          return;
        }
        setCurrentRegion(region.id);
        var times;
        if (ALLOW_OVERLAPS) {
          times = [region.start, region.end];
          handler.checkOverlaps();
        } else {
          times = preventOverlappingsOnCreation(region)
          console.log(times)
          if (times[0] != -1) {
            region.update({
              start: times[0],
              end: times[1]
            });
          } else {
            region.attributes['delete_event'] = false;
            region.remove();
          }
        }
        if (times[0] != -1) {
          var region_data = {
            start_time: times[0],
            end_time: times[1],
            annotation: '{{ annotation.id }}',
            color: region.color
          };
          if ('event_id' in region.attributes) {
            region_data['event_id'] = region.attributes['event_id']
          }
          $.ajax({
            type: "POST",
            url: '../update_end_event/',
            dataType: 'json',
            data: {
              region_data: JSON.stringify(region_data),
              csrfmiddlewaretoken: '{{csrf_token}}'
            },
            success: function (data) {
              region = wavesurfer.regions.list[currentRegionId];
              region.attributes['event_id'] = data.event_id;
            }
          });
        }
      }

      $("#tag_button").click(function () {
        var region = handler.findRegionById(currentRegionId),
            tokens = $('#tags-input').tokenfield('getTokens'),
            tags = [];
        for (var i in tokens) {
          tags.push(tokens[i].value);
        }
        if (region != null && tags.length) {
          region.attributes.tags = getUniqueItems(tags.concat(region.attributes.tags));
          updateEvent(region);
          redrawTagsForRegion(region);
        }
      });

      $('#back-annotations-button').on('click', function () {
        $.ajax({
          type: "DELETE",
          url: '{% url 'regions' %}',
          dataType: 'json',
          beforeSend: function(xhr) {
            xhr.setRequestHeader("X-CSRFToken", '{{ csrf_token }}');
          },
          data: {'annotation_id': {{ annotation.id }} },
          success: function () {
            location.reload();
          }
        });
      });

      $('#solve-overlaps-button').on('click', function () {
        var allRegions = handler.getAllRegions();

        // check classes
        var regionsWithoutClass = 0;
        allRegions.forEach(function (region) {
          if (typeof region.attributes.class == 'undefined' || region.attributes.class == 'None' || region.attributes.class == '') {
            regionsWithoutClass += 1;
          }
        });

        if (regionsWithoutClass) {
          var modalWindow = $('#modal-window'),
              text = '<p>Regions without class: ' + regionsWithoutClass + '</p>' +
                  '<p>Please assign a class to all regions before solving the overlaps.</p>';
          modalWindow.find('.modal-title').text('Error');
          modalWindow.find('.modal-body').html(text);
          modalWindow.modal('show');
          return;
        }

        $('body').removeClass('loaded');

        solveOverlaps(0, allRegions);

        switchToRegionMode();
      });

      // in "one more iteration" use compare only with new regions
      var newRegions = {};
      function solveOverlaps(totalOverlapsCount, allRegions) {
        /*
         find overlap
         there can be 4 types of overlap:
         1. current_region inside temp_region
         2. temp_region inside current_region
         3. current_region.end overlap on temp_region.start
         4. current_region.start overlap on temp_region.end
         5. overlap with multiclasses (regions limits can be the same)
        */
        var oneMoreIteration = false;
        if (typeof allRegions == 'object') {
          allRegions = $.map(allRegions, function (item) {
            return item;
          });
        }

        var region_borders = [];
        allRegions.forEach(function (current_region) {
          if (typeof current_region.deleted != 'undefined') {
            return;
          }
          if (!region_borders.includes(current_region.start)) {
            region_borders.push(current_region.start)
          }
          if (!region_borders.includes(current_region.end)) {
            region_borders.push(current_region.end)
          }
        });

        region_borders.sort();

        for (var i = 0; i < region_borders.length - 1; i++) {
          classes = []
          tags = []
          allRegions.forEach(function (current_region) {
            if (region_borders[i] >= current_region.start && region_borders[i +1] <= current_region.end) {
              classes.push(current_region.attributes.class)
              current_region_tags = typeof current_region.attributes.tags != 'undefined' ? current_region.attributes.tags : [];
              tags = tags.concat(current_region_tags)
              color = current_region.color
            }
          });

          newRegions[i] = {}
          newRegions[i]['classes'] = getUniqueItems(classes)
          newRegions[i]['tags'] = getUniqueItems(tags)
          newRegions[i]['start'] = region_borders[i]
          newRegions[i]['end'] = region_borders[i + 1]
          if (newRegions[i]['classes'].length > 1) {
            newRegions[i]['color'] = OVERLAP_REGION_COLOR;
          } else {
            newRegions[i]['color'] = color;
          }
        }

        allRegions.forEach(function (current_region) {
          current_region.attributes['delete_event'] = false
          current_region.remove()
        });

        for (var key in newRegions) {
          var newRegion = handler.addRegion(
            handler.getMainWavesurfer(),
            newRegions[key]['classes'].join(' '),
            newRegions[key]['tags'],
            -1, //shouldn't the id be passed from db to frontend?
            newRegions[key]['start'],
            newRegions[key]['end'],
            newRegions[key]['color'],
            false //is loaded
          );
          createNewRegion(newRegion) // function needs change in declaration
        }        
      }

      function sleep(miliseconds) {
         var currentTime = new Date().getTime();

         while (currentTime + miliseconds >= new Date().getTime()) {}
      }


      function checkClassProminenceIsFilled() {
        if (!REGIONS_STATE) {
          return true;
        }
        var wavesurfer = handler.getMainWavesurfer();
        for (var i in wavesurfer.regions.list) {
          var region = wavesurfer.regions.list[i],
              region_classes = region.attributes.class.split(' ');
          // only regions with multi classes
          if (region_classes.length < 2) {
            continue;
          }
          for (var j in region_classes) {
            var className = region_classes[j];
            if (region.attributes.classProminences[className] == '0') {
              return false;
            }
          }
        }
        return true;
      }


      $(".finish-annotation-button").click(function() {
        var modalWindow = $('#modal-window');
        if (ALLOW_OVERLAPS && handler.checkOverlaps()) {
          modalWindow.find('.modal-title').text('Error');
          modalWindow.find('.modal-body').text('First solve all the overlaps');
          modalWindow.modal('show');
          return;
        }
        if (!checkClassProminenceIsFilled()) {
          modalWindow.find('.modal-title').text('Error');
          modalWindow.find('.modal-body').text('First you need to assign a prominence value to all regions with more than one class');
          modalWindow.modal('show');
          return;
        }

        var loadNextAnnotation = $(this).data('load-next');


        $.ajax({
          type: "POST",
          url: '{% url 'finish_annotation' id=annotation.id %}',
          dataType: 'json',
          beforeSend: function (xhr) {
            xhr.setRequestHeader("X-CSRFToken", '{{ csrf_token }}');
          },
          data: {},
          success: function (response) {
            var modalWindow = $('#modal-window'),
                text = 'Annotation is finished.';
            if (loadNextAnnotation == '1') {
              // if have next annotation url - redirect
              if (response.next_annotation_url != '') {
                location.href = response.next_annotation_url;
              } else {
                text += '<p><b>There are no more segments to annotate for this project.</b></p>';
              }
            }
            modalWindow.find('.modal-title').text('Success');
            modalWindow.find('.modal-body').html(text);
            modalWindow.modal('show');
          }
        });
      });

      $('#tags-input').tokenfield();


      $('#switch-view').on('click', function () {
        var parsedUrl = url.parse(location.href),
            params = parsedUrl.get,
            port = parsedUrl.port == undefined ? '': (':' + parsedUrl.port);
        if ('visualization' in params) {
          delete params['visualization'];
        } else {
          params['visualization'] = 1;
        }
        var newUrl = parsedUrl.scheme + '://' + parsedUrl.host + port + parsedUrl.path + '?' + $.param(params)
        window.location = newUrl;
      });
    {% endif %}

  </script>

  <script src="{% static 'js/annotator/hotkeys.js' %}"></script>

{% endblock %}