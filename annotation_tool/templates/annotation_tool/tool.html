{% extends base_template %}
{% load staticfiles %}

{% block title %}Annotation tool{% endblock %}

{% block header %}Annotation tool{% endblock %}

{% block body_class %}loaded{% endblock %}

{% block body_block %}

  <script src="{% static 'js/annotator/lib/wavesurfer.min.js' %}"></script>
  <script src="{% static 'js/annotator/src/wavesurfer.regions.js' %}"></script>
  <script src="{% static 'js/annotator/colormap/colormap.min.js' %}"></script>
  <script src="{% static 'js/annotator/lib/wavesurfer.spectrogram.min.js' %}"></script>
  <script src="{% static 'js/annotator/src/wavesurfer.drawer.extended.js' %}"></script>
  <script src="{% static 'js/bootstrap-tokenfield.min.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/annotator/src/components.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/annotator/src/wavesurfer.labels.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/url.js' %}"></script>
  <link rel="stylesheet" href="{% static 'css/annotator/font-awesome.min.css' %}">
  <link rel="stylesheet" href="{% static 'css/bootstrap-tokenfield.min.css' %}">

  <div class="container">
    <div class="row">
      <div class="col-xs-6">
        <button type="button" class="btn btn-default" data-toggle="collapse" data-target="#tips-container">Annotation tips</button>
        <div class="collapse in" id="tips-container">
          <h5>Read and get used to the controls. Annotation will be much easier.</h5>
          <h5>Do not worry about silences, we will annotate them for you.</h5>
        </div>
      </div>
      <div class="col-xs-6">
        <button type="button" class="btn btn-default" data-toggle="collapse" data-target="#controls-container">Controls</button>
        <div class="collapse" id="controls-container">
          <h5 class="common-control"><strong>Space bar</strong>: play / pause audio.
          </h5>
          {% if not regions %}
          <h5>
              <strong>Create new region</strong>: <strong>click</strong> and <strong>drag</strong> on the waveform.
          </h5>
          {% endif %}
          <h5 class="common-control">
            <strong>Select region</strong>: <strong>double-click</strong> on <strong>region</strong> or <strong>click</strong> on <strong>region's label</strong>.</h5>
          {% if not regions %}
            <h5><strong>Delete region</strong>: <strong>ctrl+Click</strong> on it or <strong>click</strong> on <strong>region's X button</strong>.</h5>
            <h5><strong>Set class</strong>: <strong>click</strong> on <strong>label</strong> or use the <strong>shortcut</strong>.</h5>
            <h5 class="only-without-overlap"><strong>Regions cannot overlap</strong>. Use this to <strong>easily concatenate regions.</strong></h5>
            <h5 class="only-without-overlap"><strong>'f' key</strong>: <strong>glue</strong> the selected region limits to the closer borders. <strong>f + Ctrl (+ Shift)</strong> glue them only to the <strong>left (right) limit</strong>.</h5>
          {% endif %}
          <h5 class="common-control"><strong>'s' key</strong>: set the <strong>player</strong> at the <strong>beginning</strong> of the audio.
          </h5>
          <h5 class="common-control"><strong>'b' key</strong>: set the <strong>player</strong> at the <strong>beginning</strong> of the <strong>selected region</strong>.</h5>
          {% if not regions %}
          <h5><strong>Adjusting limits</strong>: <strong>ctrl (+ Shift) + Left/Right Arrows</strong> precisely adjusts <strong>left (right) region limits</strong>.</h5>
          {% endif %}
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-xs-6">
        <button id="switch-view" class="btn btn-success">Switch view</button>
      </div>
      <div class="col-xs-6">
        {% if not request.is_superuser %}
          <div class="row control-form">
            <div class="col-md-12">
              <div style="float: right;">
                {% if project.overlap %}
                  <button id="solve-overlaps-button" class="btn btn-warning">Solve overlaps</button>
                  <button id="back-annotations-button" class="btn btn-warning">Back to annotation</button>
                {% endif %}
                <button data-load-next="0" class="btn btn-primary finish-annotation-button">Finish annotation</button>
                <button data-load-next="1" class="btn btn-primary finish-annotation-button">Finish annotation and load next</button>
              </div>
            </div>
          </div>
        {% endif %}
      </div>
    </div>

    <div id="waveform"></div>

    <div style="text-align: center">
      <button class="btn btn-primary" id="play-pause-main-button">
        <i class="glyphicon glyphicon-play"></i>
        Play /
        <i class="glyphicon glyphicon-pause"></i>
        Pause
      </button>
    </div>

    <div class="row control-form">
      <div class="col-md-1" id="class-panel-header">Class</div>
      <div class="col-md-11">
        {% for name, color, shortcut in classes %}
          <div class="class-btn" data-class-color="{{ color }}" data-class-name="{{ name }}">{{ name }} <span class="shortcut">({{ shortcut }})</span></div>
        {% endfor %}
      </div>
    </div>
    <div class="row control-form tags-input-container">
      <div class="col-md-1" id="tags-panel-header">Tags</div>
      <div class="col-md-6">
        {% if not request.user.is_superuser %}
          <div class="col-md-8">
            <input type="text" class="form-control" id="tags-input" value="">
          </div>
          <div class="col-md-3"><button class="btn" id="tag_button">Add tags</button></div>
        {% endif %}
      </div>
    </div>
    <div class="row control-form">
      <div class="col-md-1" id="regions-mode-tag-container"><span id="regions-mode-tag-label">Tags</span></div>
      <div class="col-md-2"></div>
      <div class="col-md-7" id="tags-container"></div>
    </div>
    <div id="class-prominence-container">
      <div class="class-prominence-item fake-item">
        <div class="prominence-label-container">
          <div class="prominence-label"></div>
        </div>
        <div class="prominence-circles">
          {% for id, name in prominence_choices %}
            <div class="circle" data-toggle="tooltip" data-placement="bottom" data-id="{{ id }}"
                 title="{{ name }}"></div>
          {% endfor %}
        </div>
      </div>
    </div>
    <div>&nbsp;</div>
    <div id="modal-window" class="modal fade" role="dialog">
      <div class="modal-dialog">

        <!-- Modal content-->
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal">&times;</button>
            <h4 class="modal-title"></h4>
          </div>
          <div class="modal-body">

          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div>

      </div>
    </div>
  </div>
  {% if request.user.is_superuser %}
    <style>
      .wavesurfer-region .fa-times-circle {
        display: none;
      }
    </style>
  {% endif %}
  {% if regions %}
    <style>
      .delete-tag-button {
        display: none;
      }
    </style>
  {% endif %}
  <script type="text/javascript">

    wavesurferHandler = {
      // contain all wavesurfers
      container: [],
      labels: [],

      getMainWavesurfer: function() {
        return this.container[0];
      },

      getAllRegions: function() {
        var regions = [];
        this.container.forEach(function (wavesurfer) {
          Object.keys(wavesurfer.regions.list).forEach(function (id) {
            regions.push(wavesurfer.regions.list[id]);
          });
        });
        return regions;
      },

      // Create color map for spectrogram
      getSpectrogramColorMap: function() {
        return colormap({
          colormap: magma,
          nshades: 256,
          format: 'rgb',
          alpha: 1
        });
      },

      addContainerForWavesurfer: function () {
        var mainContainer = $('#waveform'),
            lastContainer = mainContainer.find('.container:last'),
            lastId = lastContainer.length ? parseInt(lastContainer.data('container-id')) : 0,
            classForNewContainer = 'container-' + (lastId + 1);

        // labels
        var labelsContainer = $('<div></div>')
            .addClass('labels');

        // container
        var newContainer = $('<div></div>')
          .append(labelsContainer)
          .attr('data-container-id', lastId + 1)
          .addClass('container ' + classForNewContainer);

        mainContainer.append(newContainer);

        return '.' + classForNewContainer;
      },

      addWavesurfer: function () {
        var container = this.addContainerForWavesurfer(),
            colorMap = this.getSpectrogramColorMap(),
            wavesurfer = WaveSurfer.create({
              container: container,
              waveColor: 'violet',
              progressColor: 'purple',
              normalize: true,
              fillParent: true,
              height: WAVESURFER_HEIGHT,
              colorMap: colorMap,
              fftSamples: WAVESURFER_HEIGHT * 2
        });

        wavesurfer.setVolume(0);

        wavesurfer.params.visualization = '{{ visualization }}';

        wavesurfer.load("{% url 'media' tmp_segment_path %}");

        // Create labels (labels that appear above each region)
        var labels = Object.create(WaveSurfer.Labels);
        labels.init({
          wavesurfer: wavesurfer,
          container: container + ' .labels'
        });
        this.labels.push(labels);

        // Create the play button and time that appear below the wavesurfer
        var playBar = new PlayBar(wavesurfer);
        playBar.create();

        this.container.push(wavesurfer);

        this.bindEvents(wavesurfer);

        return wavesurfer;
      },

      isMainWavesurfer: function (wavesurfer) {
        return this.container.length && this.container[0] == wavesurfer;
      },

      seekTo: function (position) {
        this.container.forEach(function (wavesurfer) {
          wavesurfer.seekTo(position);
        });
      },

      enableDragSelection: function () {
        this.container.forEach(function (wavesurfer) {
          wavesurfer.enableDragSelection({});
        });
      },

      disableDragSelection: function () {
        this.container.forEach(function (wavesurfer) {
          wavesurfer.disableDragSelection({});
        });
      },

      findRegionById: function (id) {
        for (var i in this.container) {
          var wavesurfer = this.container[i];
          if (wavesurfer.regions.list[id] != undefined) {
            return wavesurfer.regions.list[id];
          }
        }
        return null;
      },

      getWavesurferByRegion: function (region) {
        if (region != null) {
          for (var i in this.container) {
            var wavesurfer = this.container[i];
            if (wavesurfer.regions.list[region.id] == region) {
              return wavesurfer;
            }
          }
        }
        return null;
      },

      bindEvents: function (wavesurfer) {
        var isMainWavesurfer = this.isMainWavesurfer(wavesurfer),
            that = this;

        wavesurfer.on('region-created', function (region) {
          onRegionCreated(region);
        });

        wavesurfer.on('region-update-end', function (region, event, eventType) {
          if (eventType == 'drag') {
            return;
          }
          setTimeout(function () {
            var check_region = wavesurfer.regions.list[region.id];
            // region was deleted
            if (typeof check_region != 'undefined') {
              onRegionUpdateEnd(wavesurfer, region);
            }
          }, 50);
        });

        wavesurfer.on('region-removed', function (region) {
          setCurrentRegion(-1);
          resetHTML();
          var region_data = {event_id: region.attributes['event_id']};

          if ('click_remove' in region.attributes) {
            insertLog("click-delete region", getTime(), region.attributes.class)
            console.log("click delete")
          } else if (!('delete' in region.attributes)) {
            insertLog("cross-delete region", getTime(), region.attributes.class)
            console.log("cross delete")
          }

          if (!('delete' in region.attributes)) {
            $.ajax({
              type: "POST",
              url: '{% url 'remove_event' %}',
              dataType: 'json',
              data: {
                region_data: JSON.stringify(region_data),
                csrfmiddlewaretoken: '{{csrf_token}}'
              },
              success: function (response) {
                that.checkOverlaps();
              }
            });
          } else {
            delete region.attributes['delete'];
          }
        });

        wavesurfer.on('region-dblclick', function (region, event) {
          setCurrentRegion(region.id);
          if (event.button == 0 && event.ctrlKey == false) {
            // open prominence window if Region have multi class
            var classes = typeof region.attributes.class != 'undefined' ? region.attributes.class.split(' ') : [];
            if (REGIONS_STATE && classes.length > 1) {
              toggleProminencePopup(classes, region, $(region.element).offset());
            }
          }
        });

        wavesurfer.on('region-click', function (region, event) {
          if (event.button == 0 && event.ctrlKey == true && !REGIONS_STATE) {
            event.stopPropagation();
            event.preventDefault();
            region.attributes['click_remove'] = true
            region.remove();
          }
        });

        wavesurfer.on('ready', function () {
          {% if request.user.is_superuser %}
            wavesurfer.initRegions()
            wavesurfer.disableDragSelection({})
          {% else %}
            wavesurfer.enableDragSelection({})
          {% endif %}

          if (isMainWavesurfer) {
            loadRegions(wavesurfer);
            wavesurfer.play();
            that.labels[0].rearrange();
          }
        });

        wavesurfer.on('seek', function (value) {
          if (isMainWavesurfer) {
            insertLog("seek", getTime(), value.toString())
            console.log("seek")
          }
        });

        wavesurfer.on('finish', function () {
          if (isMainWavesurfer) {
            insertLog("end of waveform", getTime())
            console.log("end of waveform")
          }
        });
      },

      rearrangeLabels: function () {
        that = this;
        that.labels[0].rearrange();
      },

      playPause: function () {
        wavesurfer = this.getMainWavesurfer();
        wavesurfer.playPause();
        time = wavesurfer.getCurrentTime();
        if (this.isPlaying()){
          insertLog("play", getTime(), time.toString());
          console.log("play")
        } else {
          insertLog("pause", getTime(), time.toString());
          console.log("pause")
        }
      },

      isPlaying: function () {
        return this.getMainWavesurfer().isPlaying();
      },

      addRegion: function(wavesurfer, classes, tags, id, start_time, end_time, color, loaded) {
        var attrs = {
          'class': classes,
          'tags': tags,
          'region_id': id,
          'event_id': id
        };

        if (loaded) {
          attrs['loaded'] = true;
        } else {
          attrs['created_overlap'] = true;
        }
        var region = wavesurfer.addRegion({
          attributes: attrs,
          start: start_time,
          end: end_time,
          color: color,
          drag: false,
          annotation: classes,
          {% if request.user.is_superuser %}
            resize: false
          {% endif %}
        });

        return region;
      },

      checkOverlaps: function () {
        if (REGIONS_STATE) {
          return false;
        }
        var overlapWasFound = false,
            that = this;
        this.container.forEach(function (wavesurfer) {
          for (var i in wavesurfer.regions.list) {
            if (overlapWasFound) {
              break;
            }
            var current_region = wavesurfer.regions.list[i];
            that.container.forEach(function (temp_wavesurfer) {
              Object.keys(temp_wavesurfer.regions.list).forEach(function (id) {
                var temp_region = temp_wavesurfer.regions.list[id];
                if (current_region != temp_region) {
                      overlap = current_region.start <= temp_region.end && current_region.end >= temp_region.start
                  if (overlap) {
                    overlapWasFound = true;
                    return;
                  }
                }
              });
            });
          }
        });

        $('#solve-overlaps-button').attr('disabled', !overlapWasFound);
        return overlapWasFound;
      },

      clearRegionsOnBack: function () {
        this.container.forEach(function (wavesurfer) {
          Object.keys(wavesurfer.regions.list).forEach(function (id) {
            region = wavesurfer.regions.list[id];
            region.attributes['delete'] = false;
            region.remove();
          });
        });
      },

      init: function () {
        this.addWavesurfer().setVolume(1);
      }
    };

    wavesurferHandler.create = function (params) {
      var handler = Object.create(wavesurferHandler);
      handler.init(params);
      return handler;
    };


    // init
    var ALLOW_OVERLAPS = {% if project.overlap %}true{% else %}false{% endif %};
    var CLASS_DICT = {{ class_dict|safe }};
    var currentRegionId = -1;
    var OVERLAP_REGION_COLOR = 'rgba(220, 220, 220, 0.8)';
    var WAVESURFER_HEIGHT = 128;
    var REGIONS_STATE = false;
    var d = new Date();
    var START_TIME = d.getDate();
    insertLog('start', 0.0)
    console.log("start")
    var handler = new wavesurferHandler.create();

    $('#add-wavesurfer-button').on('click', function () {
      handler.addWavesurfer();
    });

    $('#play-pause-main-button').on('click', function () {
      handler.playPause();
    });

    function getTime() {
      return (d.getDate() - START_TIME) / 1000.;
    }

    function insertLog(action, time, value="") {
      log_data = {'action': action,
                  'time': time,
                  'value': value,
                  'annotation': '{{ annotation.id }}'}
      $.ajax({
        type: "POST",
        url: '../insert_log/',
        dataType: 'json',
        data: {
          log_data: JSON.stringify(log_data),
          csrfmiddlewaretoken: '{{csrf_token}}'
        },
        success: function (response) {
        }
      });

    }

    function renderNumbersForControlPanel() {
      if (ALLOW_OVERLAPS) {
        $('.only-without-overlap').remove();
      }
      var index = 0,
          numbers = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮'];
      $('#controls-container h5').each(function () {
        $(this).prepend('<span class="number">' + numbers[index++] + '</span>&nbsp;');
      });
    }
    renderNumbersForControlPanel();

    function renderNumbersForTipsPanel() {
      var index = 0,
          numbers = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮'];
      $('#tips-container h5').each(function () {
        $(this).prepend('<span class="number">' + numbers[index++] + '</span>&nbsp;');
      });
    }
    renderNumbersForTipsPanel();

    function switchToRegionMode() {
      REGIONS_STATE = true;
      $('#solve-overlaps-button, region .fa-times-circle, #tag_button, region handle, #add-wavesurfer-button, #tags-input-tokenfield, .tags-input-container').hide();
      $('.class-btn').css('cursor', 'default');
      $('#back-annotations-button, #regions-mode-tag-label').show();
      handler.disableDragSelection();
    }

    function switchToEventMode() {
      REGIONS_STATE = false;
      $('#solve-overlaps-button, region .fa-times-circle, #tag_button, region handle, #add-wavesurfer-button, #tags-input-tokenfield, .tags-input-container').show();
      $('.class-btn').css('cursor', 'pointer');
      $('#back-annotations-button, #regions-mode-tag-label').hide();
      closeProminencePopup();
      handler.enableDragSelection();
    }

    function getUniqueItems(items) {
      var unique = [];
      items.forEach(function (item) {
        if (unique.indexOf(item) < 0) {
          unique.push(item);
        }
      });
      return unique;
    }

    function redrawClassForRegion(region) {
      $('.class-btn').removeClass('active');
      if (typeof region != 'undefined' && region != null && 'class' in region.attributes) {
        region.attributes['class'].split(' ').forEach(function (name) {
          if (name != '') {
            $('div[data-class-name=' + name + ']').addClass('active');
          }
        });
      }
    }

    $('.class-btn').on('click', function () {
      var region = handler.findRegionById(currentRegionId),
          data = $(this).data();
      if (region == null || REGIONS_STATE) {
        return null;
      }
      setClassForRegion(region, data.className, data.classColor);

    });

    function loadRegions(wavesurfer) {
      // Do it with AJAX and return all info for all regions
      {% if regions %}
        {% for region in regions %}
          var tags = [];
          {% for tag in region.tags.all %}
            tags.push('{{ tag.name }}')
          {% endfor %}
          var region = handler.addRegion(wavesurfer, '{{ region.classes.all|join:" " }}', tags, {{ region.id }}, {{ region.start_time }}, {{ region.end_time }}, '{{ region.color }}', true);
          {% if region.classes.count > 1 %}
            region.attributes.classProminences = {};
            {% for class_prominence in region.classes.all %}
              region.attributes.classProminences['{{ class_prominence.class_obj.name }}'] = {{ class_prominence.prominence|default_if_none:'0' }};
            {% endfor %}
          {% endif %}
        {% endfor %}
        switchToRegionMode();
      {% else %}
        {% for event in events %}
          var tags = [];
          {% for tag in event.tags.all %}
            tags.push('{{ tag.name }}')
          {% endfor %}
          handler.addRegion(wavesurfer, '{{ event.event_class|default_if_none:'' }}', tags, {{ event.id }}, {{ event.start_time }}, {{ event.end_time }}, '{{ event.color }}', true);
        {% endfor %}
      {% endif %}
      setCurrentRegion(-1);
    }

    function getDuration() {
      return handler.getMainWavesurfer().getDuration() - 0.0001;
    }

    function preventOverlapsOnCreation(region) {
      var new_start = region.start,
          new_end = region.end,
          wavesurfer = handler.getMainWavesurfer(),
          overlap = false;
      if (new_end > getDuration()) {
        new_end = getDuration()
      }
      number_of_partial_overlaps = 0;
      for (var id in wavesurfer.regions.list) {
        if (id == region.id) {
          continue;
        }
        var temp_region = wavesurfer.regions.list[id],
            offset = $(temp_region.element)[0].offsetLeft;

        if (region.start <= temp_region.end && region.end >= temp_region.start) {
          overlap = true;
          if (region.start >= temp_region.start && region.end <= temp_region.end) {
            new_start = -1;
            break;
          } else if (region.start <= temp_region.start && region.end >= temp_region.end) {
            new_start = -1;
            break;
          } else if (region.start <= temp_region.start && region.end <= temp_region.end) {
            number_of_partial_overlaps += 1;
            new_end = temp_region.start;
          } else if (region.start >= temp_region.start && region.end >= temp_region.end) {
            number_of_partial_overlaps += 1;
            new_start = temp_region.end;
          }
        }
      };
      if (number_of_partial_overlaps >= 2) {
        new_start = -1;
      }
      if (overlap == true) {
        insertLog("prevent overlap", getTime());
        console.log("prevent overlap")
      }

      return [new_start, new_end]
    }


    function updateClassProminence(region_id, className, prominence) {
      prom_dict = {
        'region_id': region_id,
        'class_name': className,
        'prominence': prominence
      }
      $.ajax({
        type: "POST",
        url: '../update_class_prominence/',
        dataType: 'json',
        data: {
          prom_dict: JSON.stringify(prom_dict),
          csrfmiddlewaretoken: '{{csrf_token}}'
        },
        success: function (response) {
          insertLog(
              "update class prominence",
              getTime(),
              className + ' ' + prominence.toString());
          console.log("update class prominence")
        }
      });
    }

    function closeProminencePopup() {
      var popup = $('#class-prominence-container')
      popup.removeClass('active');
    }

    function toggleProminencePopup(classes, region, offset) {
      var popup = $('#class-prominence-container');
      var offsetLeft1 = offset.left;
      var offsetLeft2 = offset.left - popup.width() + region.element.clientWidth;

      // close popup if click on same region
      if (popup.hasClass('active') && (popup.offset().left == offsetLeft1 || popup.offset().left == offsetLeft2)) {
        popup.removeClass('active');
        insertLog("untoggle prominence popup", getTime(), region.attributes.class)
        console.log("untoggle prominence popup")
        return;
      } else {
        insertLog("toggle prominence popup", getTime(), region.attributes.class)
        console.log("toggle prominence popup")
      }

      // open popup
      if (region.start <= getDuration() / 2.) {
        popup.css({
          'top': (offset.top + WAVESURFER_HEIGHT) + 'px',
          'left': offsetLeft1 + 'px'
        });
        popup.addClass('active');
      } else {
        popup.css({
          'top': (offset.top + WAVESURFER_HEIGHT) + 'px',
          'left': offsetLeft2 + 'px'
        });
        popup.addClass('active');
      }

      // remove old classes
      popup.find('.class-prominence-item').not('.fake-item').remove();

      // add current classes
      var fakeItem = popup.find('.fake-item');
      for (var i in classes) {
        var newItem = fakeItem.clone(),
            className = classes[i];
        newItem.removeClass('fake-item');
        newItem.find('.prominence-label').text(className);
        var initProminence = region.attributes.classProminences[className];
        newItem.find('.circle[data-id=' + initProminence + ']').addClass('active');
        popup.append(newItem);

        // click on circle to set prominence
        $(newItem).find('.circle').on('click', function () {
          var className = $(this).closest('.class-prominence-item').find('.prominence-label').text(),
              prominence = $(this).data('id');
          updateClassProminence(region.attributes.region_id, className, prominence);
          region.attributes.classProminences[className] = prominence;

          // mark circle as active
          $(this).closest('.prominence-circles').find('.circle').removeClass('active');
          $(this).addClass('active');
        });
      }

      // activate tooltips
      $('[data-toggle="tooltip"]').tooltip();
    }

    function updateEvent(region) {
      var region_data = {
        event_id: region.attributes['event_id'],
        color: region.color,
        start_time: region.start,
        end_time: region.end,
        event_class: region.attributes['class'],
        tags: region.attributes['tags']
      };

      $.ajax({
        type: "POST",
        url: '../update_event/',
        dataType: 'json',
        data: {
          region_data: JSON.stringify(region_data),
          csrfmiddlewaretoken: '{{csrf_token}}'
        },
        success: function (response) {
        }
      });
    }

    function resetHTML() {
      redrawTagsForRegion();
      redrawClassForRegion();
    }

    function deleteTagFromRegion(region, tagName) {
      if (typeof region.attributes.tags != 'undefined') {
        var position = region.attributes.tags.indexOf(tagName);
        if (position != -1) {
          region.attributes.tags.splice(position, 1);
          updateEvent(region);
          redrawTagsForRegion(region);
        }
      }
    }


    function redrawTagsForRegion(region) {
      var container = $('#tags-container');
      container.empty();
      $('#tags-input').val('');

      if (typeof region != 'undefined' && region != null && 'tags' in region.attributes && typeof region.attributes.tags != 'undefined') {
        region.attributes['tags'].forEach(function (name) {
          if (!name.length) {
            return;
          }
          var deleteTagButton = $('<i></i>')
                  .addClass('fa fa-times-circle delete-tag-button')
                  .attr('data-tag-name', name);

          var tag = $('<div></div>')
                  .addClass('tag-element')
                  .text(name);

          deleteTagButton.on('click', function () {
            deleteTagFromRegion(region, $(this).data('tag-name'))
          });

          tag.append(deleteTagButton);
          container.append(tag);
        });
      }
    }

    function createNewRegion(region) {
      if (typeof region.deleted != 'undefined') {
        return;
      }
      var region_data = {
        color: region.color,
        start_time: region.start,
        end_time: region.end,
        tags: region.attributes.tags,
        classes: region.attributes.class,
        annotation: '{{ annotation.id }}'
      };
      $.ajax({
        type: "POST",
        url: '../create_region/',
        dataType: 'json',
        data: {
          region_data: JSON.stringify(region_data),
          csrfmiddlewaretoken: '{{csrf_token}}'
        },
        success: function (data) {
          region.attributes.region_id = data.region_id
          region.attributes.classProminences = {}
          var classes = typeof region.attributes.class != 'undefined' ? region.attributes.class.split(' ') : [];
          for (var i = 0; i < classes.length; i++){
            region.attributes.classProminences[classes[i]] = 0
          }
        }
      });
    }

    function setCurrentRegion(id) {
      currentRegionId = id;
      $('tag').removeClass('active');
      if (currentRegionId != -1) {
        $('.region-label-' + currentRegionId).addClass('active');
        var region = handler.findRegionById(currentRegionId);
        if (region) {
          redrawTagsForRegion(region);
          redrawClassForRegion(region);
          updateRegionIndexes(region);
        }
        insertLog("select region", getTime(), region.attributes.class)
        console.log("select region")
      }
    }

    function updateRegionIndexes(region) {
      var baseZIndex = 100;
      $('.wavesurfer-region').each(function () {
        $(this).css('z-index', baseZIndex++);
      });
      $('region[data-id=' + region.id + ']').css('z-index', 300);
    }

    function disableDrag(region) {
      region.drag = false
    }


    {% if not request.user.is_superuser %}
      // WaveSurfer callbacks
      function onRegionCreated(region) {
        setCurrentRegion(-1);
        disableDrag(region)
        resetHTML()

        if ('loaded' in region.attributes) {
          delete region.attributes['loaded']
        } else if ('created_overlap' in region.attributes) {
          delete region.attributes['created_overlap']
        } else if ('back_to_annotation' in region.attributes) {
          delete region.attributes['back_to_annotation']
        } else {
          region.attributes['class'] = ""
          region.attributes['tags'] = []
        }
      }

      function onRegionUpdateEnd(wavesurfer, region) {
        if (REGIONS_STATE) {
          return;
        }
        if (region.end - region.start < 0.05) {
          region.attributes['delete'] = true;
          region.remove();
          return;
        }
        var times;
        if (ALLOW_OVERLAPS) {
          times = [region.start, region.end];
          handler.checkOverlaps();
        } else {
          times = preventOverlapsOnCreation(region)
          if (times[0] != -1) {
            region.update({
              start: times[0],
              end: times[1]
            });
          } else {
            region.attributes['delete'] = false;
            region.remove();
          }
        }
        if (times[0] != -1) {
          var region_data = {
            start_time: times[0],
            end_time: times[1],
            annotation: '{{ annotation.id }}',
          };
          if ('event_id' in region.attributes) {
            region_data['event_id'] = region.attributes['event_id']
          }
          $.ajax({
            type: "POST",
            url: '../update_end_event/',
            dataType: 'json',
            data: {
              region_data: JSON.stringify(region_data),
              csrfmiddlewaretoken: '{{csrf_token}}'
            },
            success: function (data) {
              region.attributes['event_id'] = data.event_id;
              insertLog("create region", getTime())
              console.log("create region")
              setCurrentRegion(region.id);
              insertLog("update region limits mouse",
                        getTime(),
                        times[0].toString() + ' ' + times[1].toString())
              console.log("update region limits")
            }
          });
        }
      }

      $("#tag_button").click(function () {
        var region = handler.findRegionById(currentRegionId),
            tokens = $('#tags-input').tokenfield('getTokens'),
            tags = [];
        for (var i in tokens) {
          tags.push(tokens[i].value);
        }
        if (region != null && tags.length) {
          region.attributes.tags = getUniqueItems(tags.concat(region.attributes.tags));
          updateEvent(region);
          redrawTagsForRegion(region);
        }
      });

      $('#back-annotations-button').on('click', function () {
        back_data = {annotation: '{{ annotation.id }}'}
        $.ajax({
          type: "POST",
          url: '../remove_regions/',
          dataType: 'json',
          data: {
            back_data: JSON.stringify(back_data),
            csrfmiddlewaretoken: '{{csrf_token}}'
          },
          success: function (event_dict) {
            handler.clearRegionsOnBack()
            for (var i = 0; i < Object.keys(event_dict).length; i++) {
              region = handler.addRegion(
                handler.getMainWavesurfer(),
                event_dict[i]['event_class'],
                event_dict[i]['tags'],
                event_dict[i]['event_id'],
                event_dict[i]['start_time'],
                event_dict[i]['end_time'],
                event_dict[i]['color'],
                true
              );
              region.attributes['back_to_annotation'] = true;
            }
            switchToEventMode();
            handler.rearrangeLabels();
            insertLog("back to annotation", getTime())
            console.log("back to annotation")
          }
        });
      });

      $('#solve-overlaps-button').on('click', function () {
        var allRegions = handler.getAllRegions();

        // check classes
        var regionsWithoutClass = 0;
        allRegions.forEach(function (region) {
          if (typeof region.attributes.class == 'undefined' || region.attributes.class == 'None' || region.attributes.class == '') {
            regionsWithoutClass += 1;
          }
        });

        if (regionsWithoutClass) {
          var modalWindow = $('#modal-window');
          modalWindow.find('.modal-title').text('Wait a moment...');
          modalWindow.find('.modal-body').html('Please, assign a class to all regions before starting to solve the overlaps.');
          modalWindow.modal('show');
          return;
        }

        $('body').removeClass('loaded');

        solveOverlaps(allRegions);

        switchToRegionMode();

        insertLog("solve overlaps", getTime())
        console.log("solve overlaps")
      });

      function solveOverlaps(allRegions) {
        /*
         find overlap
         there can be 4 types of overlap:
         1. current_region inside temp_region
         2. temp_region inside current_region
         3. current_region.end overlap on temp_region.start
         4. current_region.start overlap on temp_region.end
         5. overlap with multiclasses (regions limits can be the same)
        */
        var newRegions = {};
        if (typeof allRegions == 'object') {
          allRegions = $.map(allRegions, function (item) {
            return item;
          });
        }

        var region_borders = [];
        allRegions.forEach(function (current_region) {
          if (typeof current_region.deleted != 'undefined') {
            return;
          }
          if (!region_borders.includes(current_region.start)) {
            region_borders.push(current_region.start)
          }
          if (!region_borders.includes(current_region.end)) {
            region_borders.push(current_region.end)
          }
        });

        region_borders.sort(function(a, b){
          return a - b;
        });

        for (var i = 0; i < region_borders.length - 1; i++) {
          var createRegion = false;
          var classes = []
          var tags = []
          var color = 'rgba(0, 0, 0, 0.5)'
          allRegions.forEach(function (current_region) {
            if (region_borders[i] >= current_region.start && region_borders[i + 1] <= current_region.end) {
              classes.push(current_region.attributes.class)
              var current_region_tags = typeof current_region.attributes.tags != 'undefined' ? current_region.attributes.tags : [];
              tags = tags.concat(current_region_tags)
              color = sumColor(color, current_region.color)
              createRegion = true
            }
          });
          if (createRegion) {
            newRegions[i] = {}
            newRegions[i]['classes'] = getUniqueItems(classes)
            newRegions[i]['tags'] = getUniqueItems(tags)
            newRegions[i]['start'] = region_borders[i]
            newRegions[i]['end'] = region_borders[i + 1]
            newRegions[i]['color'] = color;
          }
        }

        allRegions.forEach(function (current_region) {
          current_region.attributes['delete'] = false
          current_region.remove()
        });

        for (var key in newRegions) {
          var newRegion = handler.addRegion(
            handler.getMainWavesurfer(),
            newRegions[key]['classes'].join(' '),
            newRegions[key]['tags'],
            -1,
            newRegions[key]['start'],
            newRegions[key]['end'],
            newRegions[key]['color'],
            false
          );
          createNewRegion(newRegion)
        }
        handler.rearrangeLabels();
      }

      function checkClassProminenceIsFilled() {
        if (!REGIONS_STATE) {
          return true;
        }
        var wavesurfer = handler.getMainWavesurfer();
        for (var i in wavesurfer.regions.list) {
          var region = wavesurfer.regions.list[i],
              region_classes = region.attributes.class.split(' ');
          // only regions with multi classes
          if (region_classes.length < 2) {
            continue;
          }
          for (var j in region_classes) {
            var className = region_classes[j];
            if (region.attributes.classProminences[className] == '0') {
              return false;
            }
          }
        }
        return true;
      }

      function sumColor(color, current_color) {
        if (color == current_color) {
          return color;
        }
        var rgba = color.split('(')[1]
        rgba = rgba.substring(0, rgba.length - 1)
        var [r, g, b, a] = rgba.split(', ')
        var current_rgba = current_color.split('(')[1]
        current_rgba = current_rgba.substring(0, current_rgba.length - 1)
        var [cr, cg, cb, ca] = current_rgba.split(', ')
        rr = parseInt(r) + parseInt(cr)
        rg = parseInt(g) + parseInt(cg)
        rb = parseInt(b) + parseInt(cb)
        if (rr > 255 || rg > 255 || rb > 255) {
          max = Math.max(rr, rg, rb)
          if (max > 0) {
            rr = Math.round(rr / max) * 255
            rg = Math.round(rg / max) * 255
            rb = Math.round(rb / max) * 255
          }
        }
        result_color = 'rgba(' + rr.toString() + ', ' + rg.toString() + ', ' + rb.toString() + ', ' + a.toString() + ')'

        return result_color;
      }


      $(".finish-annotation-button").click(function() {
        var modalWindow = $('#modal-window');
        if (ALLOW_OVERLAPS && handler.checkOverlaps()) {
          modalWindow.find('.modal-title').text('Wait a moment...');
          modalWindow.find('.modal-body').text('Please, solve all the overlaps first');
          modalWindow.modal('show');
          insertLog("error", getTime(), "overlaps not solved")
          console.log("error: overlaps not solved")
          return;
        }
        if (!checkClassProminenceIsFilled()) {
          modalWindow.find('.modal-title').text('Wait a moment...');
          modalWindow.find('.modal-body').text('please, assign a prominence value to all regions with more than one class first');
          modalWindow.modal('show');
          insertLog("error", getTime(), "prominence not assigned")
          console.log("error: prominence not assigned")
          return;
        }

        var loadNextAnnotation = $(this).data('load-next');


        $.ajax({
          type: "POST",
          url: '{% url 'finish_annotation' id=annotation.id %}',
          dataType: 'json',
          beforeSend: function (xhr) {
            xhr.setRequestHeader("X-CSRFToken", '{{ csrf_token }}');
          },
          data: {},
          success: function (response) {
            var modalWindow = $('#modal-window'),
                text = 'Annotation is finished.';
            if (loadNextAnnotation == '1') {
              // if have next annotation url - redirect
              if (response.next_annotation_url != '') {
                location.href = response.next_annotation_url;
              } else {
                text += '<p><b>There are no more segments to annotate for this project.</b></p>';
              }
              insertLog("finish annotation and load next", getTime())
              console.log("finish annotation and load next")
            } else {
              modalWindow.find('.modal-title').text('Success!');
              modalWindow.find('.modal-body').html(text);
              modalWindow.modal('show');
              insertLog("finish annotation", getTime())
              console.log("finish annotation")
            }
          }
        });
      });

      $('#tags-input').tokenfield();


      $('#switch-view').on('click', function () {
        var parsedUrl = url.parse(location.href),
            params = parsedUrl.get,
            port = parsedUrl.port == undefined ? '': (':' + parsedUrl.port);
        if ('visualization' in params) {
          delete params['visualization'];
        } else {
          params['visualization'] = 1;
        }
        var newUrl = parsedUrl.scheme + '://' + parsedUrl.host + port + parsedUrl.path + '?' + $.param(params)
        window.location = newUrl;
        insertLog("switch view", getTime(), wavesurfer.params.visualization)
        console.log("switch view")
      });
    {% endif %}

  </script>

  <script src="{% static 'js/annotator/hotkeys.js' %}"></script>

{% endblock %}